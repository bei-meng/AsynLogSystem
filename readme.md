### 基于异步日志系统的云存储服务

### 1.logSystm/logsCode/Util.hpp
- Date:日期，获取当前日期
- File:判断文件是否存在，获取文件路径，创建文件路径，获取文件大小，获取文件内容
- JsonUtil: 序列化和反序列化字符串内容
    - 序列化，建造者生成->建造者实例化json写对象->调用写对象中的接口进行序列化写入
    - 反序列化类似，建造者生成->建造者实例化json读对象->调用读对象中的接口进行序列化解析
- JsonData: 单例模式，解析JsonData数据存储的相关配置，通过私有化构造函数，同时使用局部静态变量获取对象
    - config的地址也使用单例模式，静态成员初始化

### 2.日志持久化模块
- LogFlush虚基类，作为后面多种日志刷新类的基类，派生类必须实现Flush函数
- StdoutFlush类，将日志刷到标准输出
- FileFlush类，文件刷入文件，根据flush_log来决定何时刷入磁盘，0写入用户缓存，1写入内核缓存，2刷到磁盘
- RollFileFlush类，滚动日志文件，一个日志文件超过设定大小就会自动创建新的log文件，同样受到flush_log控制
- LogFlushFactory类，建造者模式，日志刷新工厂类，使用模板，完美转发实现对应日志类的构建，易扩展

### 3.异步缓冲区模块
- 业务需要写一条日志的话，会被存放到生产者缓冲区里面，使用双缓冲区设计，生产者缓冲区和消费者缓冲区，如果生产者缓冲区中有内容就和消费者缓冲区交换，不会进行数据复制。

### 4.异步工作者模块
- 使用子线程异步处理日志，消费者如果生产者缓冲区中没有数据会阻塞，等待有数据和通知，然后进行锁的获取，生产者和消费者缓冲区的交换
- bool原子变量，互斥锁，条件变量的wait函数的使用（问题最大），子线程使用回调函数处理消费者缓冲区中的日志数据

### 5.日志消息生成模块
- 日志的格式化，主要记录时间，日志等级，信息内容等，格式化完成后，就交给异步工作者模块放入生产者缓冲区中，消费者线程获取数据然后调用回调函数将数据存储下来

### 6.backlog远程备份模块
- 客户端放在业务所在服务器，会发送Fatal和Error级别的日志给服务器。发送这两个级别日志给其他服务器备份主要是防止机器crush之后无法查看日志或日志丢失
- 就是普通的tcp通信代码，稍微做了点封装
- 多线程支持多个tcp连接

### 7.简易线程池模块
- 在备份重要日志时使用线程池中线程进行网络I/O
- 创建线程池时，启动指定数量的线程，进入等待状态，直到任务队列中有新任务
- 当有新任务到来时，调用enqueue函数将任务放入任务队列，并唤醒一个等待的线程
- 被唤醒的线程从任务队列中取任务并执行
- 销毁线程时，会设置stop=true，并唤醒所有线程，等待他们结束

### 8.异步日志器模块
- 包含一个异步日志器和创建日志器的建造者，以及各个等级日志的消息组织方式。
- 最终通过该日志器调用异步工作者进行一个实际的写日志操作，同时对应ERROR和FATAL等级的日志会进入任务队列，等待线程池中线程通过回调函数进行远程服务器备份
- 创建日志器的类使用了建造者模式，方便后续做其他特性的日志器

### 9.异步日志器管理模块
- 管理异步日志器的管理者，使用单例模式实现，全局单例
- 用户生成的日志器会被添加进来，后续用户需要用到日志器的时候，根据日志器的名字获取即可

### 10.Mylog
- 一些宏函数，简化用户操作
- 因为宏替换是全局的，不管调用发生在哪里，只要符号匹配就会替换
- Debug的宏定义会替换mylog::AsyncLogger::Debug函数，自动填上文件名+行号，并且替换后，函数调用的成员函数签名的匹配

### 11.数据管理模块
- 文件上传会生成Storage.data文件，包含文件最后一次访问，修改时间，文件大小，文件存储路径，下载路径
- 程序启动后，会自动加载Storage.data，当有新的文件被上传存储时，使用json序列化方式插入新的StorageInfo
